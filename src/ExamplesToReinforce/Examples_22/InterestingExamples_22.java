package ExamplesToReinforce.Examples_22;
/*
Каков будет (результат компиляции) вывод на экран (сначала найти ответ устно,
и только за тем запустить код)?
*/
public class InterestingExamples_22 {
    public static void main(String[] args) {
        /* Помним, что строковые объекты неизменяемые и любые модификации влекут создание
        нового объекта и ссылки на него */
        String str_1 = "ok"; // Создали объект "ok"
        String str_2 = str_1; // Создали дополнительную ссылку на тот же объект "ok"
        // Переназначили ссылку str_1, на объект полученный при помощи конкатенации "ок!!!"
        str_1 += "!!!";
        /* Два разных объекта уходят на печать и сравнение.
        Значит мы увидим -> 'ok!!! , ok , false , false' */
        System.out.println(str_1 + " , " + str_2 + " , " + (str_1 == str_2) + " , " + str_1.equals(str_2));
        /* Помним, что StringBuilder позволяет создавать изменяемые объекты и проводить разнообразные
        манипуляции с ними с сохранением первоначальных ссылок */
        StringBuilder str_bdr_1 = new StringBuilder("ok"); // Создали ссылку на объект StringBuilder("ok")
        StringBuilder str_bdr_2 = str_bdr_1; // Дублировали ссылку на тот же объект
        str_bdr_1.append("!!!"); // Изменили объект на который ссылаются 2-е ссылки (str_bdr_1 и str_bdr_2)
        /* Поскольку объект один, а ссылок на него две, то все сравнения самого с собой true, а печать
        объекта по разным ссылкам даст все тот же объект. Так же у StringBuilder метод *.equals не
        перезаписан и эквивалентен оператору '=='

        Значит увидим ->  'ok!!! , ok!!! , true , true' */
        System.out.println(str_bdr_1 + " , " +
                          str_bdr_2 + " , " +
                          (str_bdr_1 == str_bdr_2) + " , " +
                          str_bdr_1.equals(str_bdr_2));
    }
}
