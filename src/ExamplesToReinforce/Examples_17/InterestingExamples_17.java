package ExamplesToReinforce.Examples_17;
/*
Сколько объектов будут пригодны для удаления их СборщикомМусора (garbage collection)
на строке с комментариями?
*/
public class InterestingExamples_17 {
    /*
    Ох, и неуверен я в своих рассуждениях, но попробую. Единственное, что я понял, как только
    на какой-либо объект перестают ссылаться, он становится жертвой сборщика мусора (что бы
    память не занимал). Но вот последовательность...
    */
    public static void main(String[] args) {
        /* Ссылка fgt_1 ссылается на объект класса ForGcTest, при этом внутри объекта есть ссылка
        на Byte b, т.е. еще один объект (любимая матрешка).*/
        ForGcTest fgt_1 = new ForGcTest();
        // Тут ситуация похожая - одна ссылка два объекта
        ForGcTest fgt_2 = new ForGcTest();
        /* Тут ссылка fgt_3 указывает на результат работы метода. В метод *.takeTest(fgt_2) передается
        копия ссылки fgt_2' (не оригинал, т.е. ссылка жива и здорова). В методе эта копия ссылки
        обнуляется и возвращается переменной fgt_3. Значит fgt_3 ни на что не указывает. */
        ForGcTest fgt_3 = fgt_1.takeTest(fgt_2);
        /* Ссылку fgt_1 перенаправили, и теперь она указывает на пустоту, т.е. первоначальный объект,
        на который она указывала (ссылалась), стал пригодным для удаления из памяти. */
        fgt_1 = null;

        /* Это означает, что на текущий момент будет доступен к очистке один объект, содержащий в себе
        другой объект или всего 2-а объекта. И тут вопрос у меня возникает, а как же ссылка на 'b' или
        тут срабатывает эффект подводной лодки, тонут все... */

        /** Комментарии **/
    }
}

class ForGcTest{
    Byte b = 10;
    ForGcTest takeTest(ForGcTest fgt){
        fgt = null;
        return fgt;
    }
}